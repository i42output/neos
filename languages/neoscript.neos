%{
    meta: {
        language: "neoscript"
        description: "Default neoGFX scripting language"
        source.file.extension: ".neo"
        source.package.specification.file.extension: ".neo"
        source.package.implementation.file.extension: ".neo"
        copyright: "Copyright (C) 2024 Leigh Johnston"
        version: "1.0.0"
    }

    libraries: [
        neos.core
        neos.math.universal
    ]
}%

program $ language.program ::= { using directive | import directive | namespace scope } ;
using directive $ source.package.import ::= ( whitespace , using , whitespace , package name , whitespace ) ;
import directive $ language.function.import ::= ( whitespace , import , whitespace , fn , whitespace , fn sig , whitespace ) ;
import directive $ language.function.import ::= ( whitespace , import , whitespace , proc , whitespace , proc sig , whitespace ) ;

namespace scope $ language.namespace.scope ::= 
    { comment | function | procedure | namespace def }
namespace def $ language.namespace ::= 
    whitespace , identifier $ language.namespace.name , whitespace , "{" , whitespace , namespace scope , whitespace , "}" , whitespace ;

function $ language.function ::= ( whitespace , fn , whitespace , fn sig , whitespace , fn body , whitespace ) ;
procedure $ language.function ::= ( whitespace , proc , whitespace , proc sig , whitespace , proc locals , whitespace , proc body , whitespace ) ;
fn sig $ language.function.signature ::= ( identifier , whitespace , '(' , whitespace , fn parameters , whitespace , ')' , whitespace , "->", whitespace , type ) ;
proc sig $ language.function.signature ::= ( identifier , whitespace , '(' , whitespace , proc parameters , whitespace , ')' ) ;
fn parameters $ language.function.parameters ::= ( fn parameter block , { whitespace , ';' , whitespace , fn parameter block } ) ;
proc parameters $ language.function.parameters ::= ( proc parameter block , { whitespace , ';' , whitespace , proc parameter block } ) ;
fn parameter block ::= [ parameter , { whitespace , ',' , whitespace , parameter } , whitespace , ':' , whitespace , type ];
proc parameter block ::= [ parameter , { whitespace , ',' , whitespace , parameter } , whitespace , ':' , whitespace , ( in | out | inout ) , whitespace , type ];
parameter $ language.function.parameter ::= identifier ;
proc locals ::= ( proc local block , { whitespace , ';' , whitespace , proc local block } ) ;
proc local block ::= [ local , { whitespace , ',' , whitespace , local } , whitespace , ':' , whitespace , type ] ;
local $ language.function.local ::= identifier ;
fn body $ language.function.body ::= scope ;
proc body $ language.function.body ::= scope ;
scope $ language.function.scope ::= ( '{' , whitespace , { statement } , whitespace , '}' ) ; 

statement $ language.statement ::= 
    expression | assignment | return statement | if statement | for loop | while loop | do while loop;

assignment $ language.assignment ::= 
    ( object , whitespace , "=" , whitespace , expression );

expression $ language.expression ::= 
    function call | boolean expression | numeric expression ;

function call $ language.expression.call ::= 
    identifier , whitespace , '(' , whitespace , arguments , whitespace , ')' ;

arguments ::= [ expression , { whitespace , ',' , whitespace , expression } ] ;

boolean expression $ language.expression.boolean ::= 
      boolean term , { whitespace , ( "or" | "||" ) , whitespace , boolean term, whitespace } $ boolean.logic.operator.or ;
boolean term ::= 
      boolean factor , { whitespace , ( "and" | "&&" ) , whitespace , boolean factor , whitespace } $ boolean.logic.operator.and ;
boolean factor ::= 
      true 
    | false 
    | ( ( "not" | "!" ) , whitespace , boolean factor ) $ boolean.logic.operator.not
    | '(' , whitespace , boolean expression , whitespace , ')' 
    | comparison expression ;
comparison expression ::= 
      numeric expression , whitespace , comparison operator , whitespace , numeric expression ;
comparison operator ::= 
      "==" $ boolean.operator.relational.equal 
    | "!=" $ boolean.operator.relational.notequal 
    | "<" $ boolean.operator.relational.lessthan
    | ">" $ boolean.operator.relational.greaterthan
    | "<=" $ boolean.operator.relational.lessthanorequal
    | ">=" $ boolean.operator.relational.greaterthanorequal ;

numeric expression $ math.expression ::= 
    term , whitespace, { ( "+" $ math.operator.add | "-" $ math.operator.subtract ) , whitespace , term } ;
term ::= 
    factor , whitespace, { ( "*" $ math.operator.multiply | "/" $ math.operator.divide ) , whitespace, factor } ;
factor ::= 
    [ "-" $ math.operator.negate ] , whitespace , primary ;
primary ::= 
    "(" , whitespace , expression , whitespace , ")" | number ;
number $ math.universal.number ::= 
    digit sequence , [ '.' , digit sequence , [ exponent ] ]
exponent ::= 
    ("e" | "E") , [ "+" | "-" ] , digit sequence ;
digit sequence ::= 
    digit , { digit } ;
digit ::= 
    "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

return statement $ language.statement.return ::= 
    ( return , whitespace , expression ) ;

if statement $ language.statement.if ::= 
    if , whitespace , '(' , whitespace , boolean expression , whitespace , ')' , whitespace , 
    ( scope | statement ) $ logic.operator.if , [ whitespace , else statement ] ;
else statement $ language.statement.else ::= 
    else , whitespace, ( scope | statement ) $ logic.operator.else , whitespace ;

for loop $ language.statement.loop ::= 
    for clause , scope
for clause ::=
    for , whitespace , '(' , whitespace , 
        [ local , whitespace , ':' , whitespace , type , whitespace , ":=" , whitespace , expression , whitespace ] $ language.assignment ,
        ';' , whitespace, boolean expression , whitespace , ';' , whitespace , ( expression | assignment ) , whitespace , ')' ;

while loop $ language.statement.loop ::= 
    while clause , scope
while clause ::=
    while , whitespace , '(' , whitespace , boolean expression , whitespace , ')' ;

do while loop $ language.statement.loop ::= 
    do, scope, while clause

type ::= bool | i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | float | double | character | string | object ;

using $ language.keyword ::= "using" ;
import $ language.keyword ::= "import" ;
namespace $ language.keyword ::= "namespace" ;
public $ language.keyowrd ::= "public" ;
protected $ language.keyowrd ::= "protected" ;
private $ language.keyowrd ::= "private" ;
override $ lanugage.keyword ::= "override" ;
final $ language.keyword ::= "final" ;
mutable $ language.keyword ::= "mutable" ;
is $ language.keyword ::= "is" ;
extends $ language.keyword ::= "extends" ;
implements $ language.keyword ::= "implements" ;
struct $ language.keyword ::= "struct" ;
class $ language.keyword ::= "class" ;
interface $ language.keyword ::= "interface" ;
auto $ language.type.auto ::= "auto" ;
def $ language.keyword ::= "def" ;
fn $ language.keyword ::= "fn" ;
proc $ language.keyword ::= "proc" ;
in $ language.keyword $ language.function.parameter.in ::= "in" ;
out $ language.keyword $ language.function.parameter.out ::= "out" ;
inout $ language.keyword $ language.function.parameter.inout ::= "inout" ;
if $ language.keyword ::= "if" ;
else $ language.keyword ::= "else" ;
for $ language.keyword ::= "for" ;
while $ language.keyword ::= "while" ;
do $ language.keyword ::= "do" ;
return $ language.keyword ::= "return" ;

package name $ source.package.name ::= alpha , { alpha | "." , alpha } ; 

identifier ::= ( alpha ) , { alphanumeric | '_' } ;

keyword ::= { alpha } + ;

comment $ language.comment $ language.whitespace ::= whitespace , "--" , { character - '\n' }, ( '\n' | ? eof ? ) ;
whitespace $ language.whitespace ::= { ' ' | '\n' | '\r' | '\t' | ? eof ? } ;

alpha ::= "A" .. "Z" | "a" .. "z" ;
alphanumeric ::= alpha | "0" .. "9" ;

isize $ language.type.object.size.signed ::= "isize" ;
usize $ language.type.object.size.unsigned ::= "usize" ;
bool $ language.type.boolean ::= "bool" ;
i8 $ language.type.i8 ::= "i8" ;
u8 $ language.type.u8 ::= "u8" ;
i16 $ language.type.i16 ::= "i16" ;
u16 $ language.type.u16 ::= "u16" ;
i32 $ language.type.i32 ::= "i32" ;
u32 $ language.type.u32 ::= "u32" ;
i64 $ language.type.i64 ::= "i64" ;
u64 $ language.type.u64 ::= "u64" ;
float $ language.type.float ::= "float" ;
double $ language.type.double ::= "double" ;
character $ language.type.character ::= "char" ;
object $ language.gc.type.object ::= identifier ;

true $ language.object.boolean.true ::= "true" ;
false $ language.object.boolean.false ::= "false" ;

raw character $ string.utf8.character ::= ( ' ' .. '\xFF' - ( '\\' | '\"' | '\'' ) | escaped character ) ;
escaped character $ string.utf8.character.LF ::= ( "\\n" ) ;
escaped character $ string.utf8.character.CR ::= ( "\\r" ) ;
escaped character $ string.utf8.character.tab ::= ( "\\t" ) ;
escaped character $ string.utf8.character.doublequote ::= ( "\\\"" ) ;
escaped character $ string.utf8.character.singlequote::= ( "\\\'" ) ;
escaped character $ string.utf8.character.backslash ::= ( "\\\\" ) ;
character literal ::= ( '\'' , raw character , '\'' ) ;
raw string $ string.utf8 ::= { raw character } ;
string literal ::= ( '\"' , raw string  , '\"' ) ;
